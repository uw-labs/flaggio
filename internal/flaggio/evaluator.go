package flaggio

//go:generate mockgen -destination=./mocks/evaluator_mock.go -package=flaggio_mock github.com/uw-labs/flaggio/internal/flaggio Evaluator,Identifier

import (
	"fmt"
	"strings"
)

// Evaluator represents an object that can evaluate a given user context
// and return an answer and/or point to other evaluators that can possibly
// return an answer.
type Evaluator interface {
	Evaluate(usrContext map[string]interface{}) (EvalResult, error)
}

// Identifier represents an object that can return an ID.
type Identifier interface {
	GetID() string
}

// EvalResult is the result generated by an Evaluator. It possibly contains
// an answer and/or a list of the next Evaluators that should be called.
type EvalResult struct {
	Answer    interface{}
	Next      []Evaluator
	evaluator Evaluator
	previous  *EvalResult
}

// Stack will generate a stack trace of the evaluation process.
func (r EvalResult) Stack() (stack []*StackTrace) {
	prev := &r
	for prev != nil {
		var id *string
		ider, ok := prev.evaluator.(Identifier)
		if ok {
			v := ider.GetID()
			id = &v
		}
		stack = append(stack, &StackTrace{
			Type: strings.Replace(
				fmt.Sprintf("%T", prev.evaluator), "flaggio.", "", 1,
			),
			ID:     id,
			Answer: prev.Answer,
		})
		prev = prev.previous
	}
	return
}

// Evaluate is the starting point for a chain of evaluations.
func Evaluate(usrContext map[string]interface{}, root Evaluator) (EvalResult, error) {
	return evaluate(usrContext, []Evaluator{root})
}

// evaluate will call all the evaluators, passing the user context as parameter
// and expect an EvalResult. The evaluation process will continue until one of the
// evaluators return an answer and no new evaluators to continue, or no more
// evaluators are left in the chain, whichever happens first.
func evaluate(usrContext map[string]interface{}, evaluators []Evaluator) (EvalResult, error) {
	// the last evaluation result that had an answer
	var lastWithResult EvalResult
	// used to keep track of the evaluator chain and generate a stack trace
	var lastInChain *EvalResult

	// go through the evaluators in the list
	for len(evaluators) > 0 {
		// get the first evaluator in the list
		evltr := evaluators[0]

		// call the evaluator and get the answer
		res, err := evltr.Evaluate(usrContext)
		if err != nil {
			return EvalResult{}, err
		}

		// attach additional data so that we can generate a stack trace
		res.evaluator = evltr
		res.previous = lastInChain
		lastInChain = &res

		if res.Answer != nil {
			if len(res.Next) == 0 {
				// we have an answer and no new evaluators were returned
				// so this is the final answer
				return res, nil
			}
			// save the result. in case no new answers are returned this will
			// be used as final answer
			lastWithResult = res
		}

		if len(res.Next) > 0 {
			// we have more evaluators, add them to the start of the list
			evaluators = append(res.Next, evaluators[1:]...)
		} else {
			// no new evaluators, remove the first evaluator from the list
			// which has just been calleed
			evaluators = evaluators[1:]
		}
	}

	// return the final answer, if any
	return lastWithResult, nil
}
